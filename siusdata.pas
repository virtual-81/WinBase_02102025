unit SiusData;

interface

uses
  Winapi.Windows,
  System.SysUtils,
  System.Classes,
  System.Net.Socket,
  System.Win.ScktComp;

const
  SHOT_ACC0= $0001;
  SHOT_ACC1= $0002;
  SHOT_ACC2= $0004;
  SHOT_ILLEGAL= $0008; // Shot fired outside practice or in excess.
  SHOT_DELETED= $0010; // Deleted by manual editing.
  SHOT_SIGHTING= $0020; // Belongs to a group of sighters
  SHOT_MARKED= $0040;  // Marked manually by coach.
  SHOT_FAST= $0080;   //Running Target : Fast Run
  SHOT_MISS= $0100;  //Shot missed the target.
  SHOT_INNERTEN= $0200; //Shot hit the inner ten or such equivalent score zone.
  SHOT_FRAME= $0400; //Shot hit the frame, that is, x, y should be disregarded.
  SHOT_DEMO= $0800;  //Shot has been generated by a random generator.
  SHOT_OVERTIME= $1000; //Shot has been recorded out of time.
  SHOT_LEFTSWEEP= $2000; //Shot has been recorded during LeftSweep (mover).
  SHOT_FRIENDSHOT= $4000; //Shot has been recorded on a different lane, but is to
                          //be counted as a valid shot. Eg in 25m Rapid Fire Pistol
  SHOT_CROSS_SHOT= $8000; //Shot has been recorded without a matching shot sensor activation.

  SHOT_KIND_OWN= 3;
  SHOT_KIND_ADVANCE= 17;

type
  TSiusCmd= procedure (cmd: string) of object;
  TSiusNameCmd= procedure (lane,startno: integer; name: string) of object;
  TSiusIssfIdCmd= procedure (startno: integer; issfid: string) of object;
  TSiusStartNoCmd= procedure (lane,startno: integer) of object;
  TSiusNationCmd= procedure (lane,startno: integer; nation: string) of object;
  TSiusUnknownCmd= procedure (cmd: string) of object;
  TSiusStartCompListCmd= procedure (time,name: string) of object;
  TSiusEndCompListCmd= procedure of object;
  TSiusEndCompetitorCmd= procedure of object;
  TSiusEndTeamCmd= procedure of object;
  TSiusEndStageCmd= procedure of object;
  TSiusShotCmd= procedure (lane,startno,kind,attr,priscore,secscore,targetindex,practicenum: integer; x,y: double) of object;
  TSiusSubTotalCmd= procedure (lane,startno,priscore,secscore: integer) of object;
  TSiusGroupHeaderCmd= procedure (lane,startno,group,kind: integer) of object;
  TSiusPracticeHeaderCmd= procedure (lane,startno,seq,code,phase: integer) of object;
  TSiusUpdateEvent= procedure (Sender: TObject; shooter,phase,group,shot: integer) of object;
  TSiusRequestDataEvent= procedure (Sender: TObject; startno: integer; out Data: TObject) of object;

  TSiusDataMonitor= class
  private
    fClient: TClientSocket;
    fNameCmd: TSiusNameCmd;
    fIssfIdCmd: TSiusISSFIDCmd;
    fStartNoCmd: TSiusStartNoCmd;
    fNationCmd: TSiusNationCmd;
    fShotCmd: TSiusShotCmd;
    fStartCompListCmd: TSiusStartCompListCmd;
    fEndCompListCmd: TSiusEndCompListCmd;
    fEndCompetitorCmd: TSiusEndCompetitorCmd;
    fUnknownCmd: TSiusUnknownCmd;
    fPracticeHeaderCmd: TSiusPracticeHeaderCmd;
    fOnDisconnect: TNotifyEvent;
    fOnConnect: TNotifyEvent;
    fEndTeamCmd: TSiusEndTeamCmd;
    fEndStageCmd: TSiusEndStageCmd;
    fOnCmd: TSiusCmd;
    fSubTotalCmd: TSiusSubTotalCmd;
    fGroupHeaderCmd: TSiusGroupHeaderCmd;
    fBuffer: string;
    fLastCommand: string;
    function get_Active: boolean;
    procedure set_Active(const Value: boolean);
    function get_Host: string;
    procedure set_Host(const Value: string);
    function get_Connected: boolean;
    procedure OnClientConnect (Sender: TObject; Socket: TCustomWinSocket);
    procedure OnClientDisconnect (Sender: TObject; Socket: TCustomWinSocket);
    procedure OnClientError (Sender: TObject; Socket: TCustomWinSocket;
      ErrorEvent: TErrorEvent; var ErrorCode: Integer);
    procedure OnClientRead (Sender: TObject; Socket: TCustomWinSocket);
    procedure ParseCommand (s: string);
  public
    constructor Create;
    destructor Destroy; override;
    property Connected: boolean read get_Connected;
    property Active: boolean read get_Active write set_Active;
    property Host: string read get_Host write set_Host;
    property OnName: TSiusNameCmd read fNameCmd write fNameCmd;
    property OnIssfID: TSiusIssfIdCmd read fIssfIdCmd write fIssfIdCmd;
    property OnStartNo: TSiusStartNoCmd read fStartNoCmd write fStartNoCmd;
    property OnNation: TSiusNationCmd read fNationCmd write fNationCmd;
    property OnUnknown: TSiusUnknownCmd read fUnknownCmd write fUnknownCmd;
    property OnStartCompetitionList: TSiusStartCompListCmd read fStartCompListCmd write fStartCompListCmd;
    property OnEndCompetitionList: TSiusEndCompListCmd read fEndCompListCmd write fEndCompListCmd;
    property OnShot: TSiusShotCmd read fShotCmd write fShotCmd;
    property OnEndCompetitor: TSiusEndCompetitorCmd read fEndCompetitorCmd write fEndCompetitorCmd;
    property OnEndTeam: TSiusEndTeamCmd read fEndTeamCmd write fEndTeamCmd;
    property OnEndStage: TSiusEndStageCmd read fEndStageCmd write fEndStageCmd;
    property OnCmd: TSiusCmd read fOnCmd write fOnCmd;
    property Client: TClientSocket read fClient;
    property OnConnect: TNotifyEvent read fOnConnect write fOnConnect;
    property OnDisconnect: TNotifyEvent read fOnDisconnect write fOnDisconnect;
    property OnSubTotal: TSiusSubTotalCmd read fSubTotalCmd write fSubTotalCmd;
    property OnGroupHeader: TSiusGroupHeaderCmd read fGroupHeaderCmd write fGroupHeaderCmd;
    property OnPracticeHeader: TSiusPracticeHeaderCmd read fPracticeHeaderCmd write fPracticeHeaderCmd;
    procedure Simulate (s: TStrings);
    property LastCommand: string read fLastCommand;
    procedure ResetBuffer;
  end;

type
  TSiusShotRec= record
    _priscore: word;
    _secscore: word;
    _sighter: boolean;
    _innerten: boolean;
  end;

  TSiusGroup= class
  private
    fShots: array of TSiusShotRec;
    function get_Shot(index: integer): TSiusShotRec;
    procedure set_Shot(index: integer; const Value: TSiusShotRec);
  public
    constructor Create;
    destructor Destroy; override;
    property Shots [index: integer]: TSiusShotRec read get_Shot write set_Shot;
    function ShotsCount: integer;
    procedure Clear;
    procedure AddShot (priscore,secscore: integer; sighter: boolean; innerten: boolean);
    function PriSum: DWORD;
    function SecSum: DWORD;
    function InnerTens: integer;
  end;

  TSiusPhase= class
  private
    fGroups: array of TSiusGroup;
    fCurrentGroup: TSiusGroup;
    function get_Group(index: integer): TSiusGroup;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    function GroupsCount: integer;
    function ShotsCount: integer;
    property Groups [index: integer]: TSiusGroup read get_Group;
    property CurrentGroup: TSiusGroup read fCurrentGroup;
    procedure SetGroup (index: integer);
    function PriSum: DWORD;
    function SecSum: DWORD;
    function InnerTens: integer;
  end;

  TLaneShooter= class
  private
    fLane: integer;
    fStartno: integer;
    fIssfid: string;
    fName: string;
    fNation: string;
    fPhases: array of TSiusPhase;
    fSighters: integer;
    fLastSighter: integer;
    fCommands: TStringList;
    fCurrentPhase: TSiusPhase;
    fObject: TObject;
    fChanged: boolean;
    function get_Phase(index: integer): TSiusPhase;
  public
    constructor Create;
    destructor Destroy; override;
    property Phases [index: integer]: TSiusPhase read get_Phase;
    function PhasesCount: integer;
    function ShotsCount: integer;
    property CurrentPhase: TSiusPhase read fCurrentPhase;
    procedure SetPhase (index: integer);
    procedure Clear;
    property Name: string read fName;
    property Nation: string read fNation;
    property IssfId: string read fIssfid;
    property Lane: integer read fLane;
    property StartNo: integer read fStartno;
    property Sighters: integer read fSighters;
    property LastSighter: integer read fLastSighter;
    property Commands: TStringList read fCommands;
    property DataObject: TObject read fObject write fObject;
    function PriSum: DWORD;
    function SecSum: DWORD;
    function InnerTens: integer;
    property Changed: boolean read fChanged;
  end;

  TShooters= class
  private
    fShooters: array of TLaneShooter;
    fRequestData: TSiusRequestDataEvent;
    fAutoAdd: boolean;
    function get_Shooter(index: integer): TLaneShooter;
//    function FindLane (lane: integer; createnew: boolean= false): TLaneShooter;
    function FindStartNo (startno: integer): integer;
  public
    constructor Create;
    destructor Destroy; override;
    function Count: integer;
    function AssignName (lane,startno: integer; name: string): integer;
    function AssignNation(lane,startno: integer; nation: string): integer;
    function AddShot (lane,startno: integer; priscore,secscore: integer; sighter: boolean; innerten: boolean): integer;
    function AssignIssfId (startno: integer; issfid: string): integer;
    function AssignLane (lane,startno: integer): integer;
    procedure Clear;
    property Shooters [index: integer]: TLaneShooter read get_Shooter;
    property OnRequestData: TSiusRequestDataEvent read fRequestData write fRequestData;
    property AutoAdd: boolean read fAutoAdd write fAutoAdd;
    function Add (startno: integer): integer;
  end;

  TSiusDataCollector= class
  private
    fSiusData: TSiusDataMonitor;
    fShooters: TShooters;
    fCommands: TStringList;
    fOnConnect: TNotifyEvent;
    fOnDisconnect: TNotifyEvent;
    fOnUpdate: TSiusUpdateEvent;
    procedure Connect (Sender: TObject);
    procedure Disconnect (Sender: TObject);
    procedure OnName (lane,startno: integer; name: string);
    procedure OnIssfId (startno: integer; issfid: string);
    procedure OnStartNo (lane,startno: integer);
    procedure OnNation (lane,startno: integer; nation: string);
    procedure OnStartCompList (time,name: string);
    procedure OnEndCompList;
    procedure OnShot (lane,startno,kind,attr,priscore,secscore,targetindex,practicenum: integer; x,y: double);
    procedure OnEndCompetitor;
    procedure OnEndTeam;
    procedure OnEndStage;
    procedure OnCmd (cmd: string);
    procedure OnGroupHeader (lane,startno,group,kind: integer);
    procedure OnPracticeHeader (lane,startno,seq,code,phase: integer);
  public
    constructor Create;
    destructor Destroy; override;
    property Shooters: TShooters read fShooters;
    property SiusData: TSiusDataMonitor read fSiusData;
    property Commands: TStringList read fCommands;
    property OnConnect: TNotifyEvent read fOnConnect write fOnConnect;
    property OnDisconnect: TNotifyEvent read fOnDisconnect write fOnDisconnect;
    procedure Reset;
    property OnUpdate: TSiusUpdateEvent read fOnUpdate write fOnUpdate;
  end;

function ShotRec (priscore,secscore: integer; sighter: boolean; innerten: boolean): TSiusShotRec;

implementation

function ShotRec (priscore,secscore: integer; sighter: boolean; innerten: boolean): TSiusShotRec;
begin
  Result._priscore:= priscore;
  Result._secscore:= secscore;
  Result._sighter:= sighter;
  Result._innerten:= innerten;
end;

{ TSiusDataMonitor }

constructor TSiusDataMonitor.Create;
begin
  inherited;
  fClient:= TClientSocket.Create (nil);
  fClient.ClientType:= ctNonBlocking;
  fClient.Port:= 4000;
  fClient.OnConnect:= OnClientConnect;
  fClient.OnDisconnect:= OnClientDisconnect;
  fClient.OnError:= OnClientError;
  fClient.OnRead:= OnClientRead;
  fBuffer:= '';
  fLastCommand:= '';
end;

destructor TSiusDataMonitor.Destroy;
begin
  fClient.Active:= false;
  fClient.Free;
  inherited;
end;

function TSiusDataMonitor.get_Active: boolean;
begin
  Result:= fClient.Active;
end;

function TSiusDataMonitor.get_Connected: boolean;
begin
  Result:= fClient.Socket.Connected;
end;

function TSiusDataMonitor.get_Host: string;
begin
  Result:= fClient.Host;
end;

procedure TSiusDataMonitor.OnClientConnect(Sender: TObject; Socket: TCustomWinSocket);
begin
  fBuffer:= '';
  if Assigned (fOnConnect) then
    fOnConnect (self);
end;

procedure TSiusDataMonitor.OnClientDisconnect(Sender: TObject; Socket: TCustomWinSocket);
begin
  fBuffer:= '';
  if Assigned (fOnDisconnect) then
    fOnDisconnect (self);
end;

procedure TSiusDataMonitor.OnClientError(Sender: TObject; Socket: TCustomWinSocket; ErrorEvent: TErrorEvent;
  var ErrorCode: Integer);
begin
  // ������
  ErrorCode:= 0;
end;

procedure TSiusDataMonitor.OnClientRead(Sender: TObject; Socket: TCustomWinSocket);
var
  c,p: integer;
  st: string;
begin
  c:= Socket.ReceiveLength;
  SetLength (st,c);
  Socket.ReceiveBuf (st [1],c);
  fBuffer:= fBuffer+st;
  st:= '';
  p:= pos (#13#10,fBuffer);
  while p> 0 do
    begin
      st:= copy (fBuffer,1,p-1);
      delete (fBuffer,1,p+1);
      try
        if Assigned (fOnCmd) then
          fOnCmd (st);
        ParseCommand (st);
      except
      end;
      p:= pos (#13#10,fBuffer);
    end;
end;

procedure TSiusDataMonitor.ParseCommand(s: string);
var
  sf: TStrings;
  p: integer;
  n,lane,startno,kind,attr,priscore,secscore,targetindex,practicenum,group: integer;
  x,y: double;
  seq,code,phase: integer;
  mnem: string;
begin
  if Trim (s)= '' then
    exit;
//  OutputDebugString (pchar (s));
  fLastCommand:= s;
  sf:= TStringList.Create;
  try
    p:= pos (';',s);
    while p> 0 do
      begin
        sf.Add (copy (s,1,p-1));
        delete (s,1,p);
        p:= pos (';',s);
      end;
    sf.Add (s);
    if sf.Count< 1 then
      begin
        sf.Free;
        exit;
      end;
    mnem:= sf [0];
    if mnem= '_NAME' then   // ��� �������
      begin
        if sf.Count< 6 then
          begin
            sf.Free;
            exit;
          end;
        val (sf [2],lane,n);
        val (sf [3],startno,n);
        if Assigned (fNameCmd) then
          fNameCmd (lane,startno,sf [5]);
      end
    else if sf [0]= '_FDID' then
      begin
        if sf.Count< 7 then
          begin
            sf.Free;
            exit;
          end;
        val (sf [5],startno,n);
        if Assigned (fIssfIdCmd) then
          fIssfIdCmd (startno,sf [6]);
      end
    else if sf [0]= '_SHID' then
      begin
        if sf.Count< 4 then
          begin
            sf.Free;
            exit;
          end;
        val (sf [2],lane,n);
        val (sf [3],startno,n);
        if Assigned (fStartNoCmd) then
          fStartNoCmd (lane,startno);
      end
    else if sf [0]= '_SNAT' then
      begin
        if sf.Count< 6 then
          begin
            sf.Free;
            exit;
          end;
        val (sf [2],lane,n);
        val (sf [3],startno,n);
        if Assigned (fNationCmd) then
          fNationCmd (lane,startno,sf [5]);
      end
    else if sf [0]= '_PRCH' then
      begin
        if sf.Count< 15 then
          begin
            sf.Free;
            exit;
          end;
        val (sf [2],lane,n);
        val (sf [3],startno,n);
        val (sf [11],seq,n);
        val (sf [13],code,n);
        val (sf [14],phase,n);
        if Assigned (fPracticeHeaderCmd) then
          fPracticeHeaderCmd (lane,startno,seq,code,phase);
      end
    else if sf [0]= '_GRPH' then
      begin
        if sf.Count< 11 then
          begin
            sf.Free;
            exit;
          end;
        val (sf [2],lane,n);
        val (sf [3],startno,n);
        val (sf [9],group,n);
        val (sf [10],kind,n);
        if Assigned (fGroupHeaderCmd) then
          fGroupHeaderCmd (lane,startno,group,kind);
      end
    else if sf [0]= '_SHOT' then
      begin
        if sf.Count< 16 then
          begin
            sf.Free;
            exit;
          end;
        val (sf [2],lane,n);
        val (sf [3],startno,n);
        val (sf [7],kind,n);
        val (sf [9],attr,n);
        val (sf [10],priscore,n);
        val (sf [11],secscore,n);
        val (sf [12],targetindex,n);
        val (sf [13],practicenum,n);
        val (sf [14],x,n);
        val (sf [15],y,n);
        if Assigned (fShotCmd) then
          fShotCmd (lane,startno,kind,attr,priscore,secscore,targetindex,practicenum,x,y);
      end
    else if sf [0]= '_SCLS' then
      begin
        if sf.Count< 7 then
          begin
            sf.Free;
            exit;
          end;
        if Assigned (fStartCompListCmd) then
          fStartCompListCmd (sf [5],sf [6]);
      end
    else if sf [0]= '_ECLS' then
      begin
        if Assigned (fEndCompListCmd) then
          fEndCompListCmd;
      end
    else if sf [0]= '_SFIN' then
      begin
      end
    else if sf [0]= '_EFIN' then
      begin
      end
    else if sf [0]= '_SCOM' then
      begin
      end
    else if sf [0]= '_ECOM' then
      begin
        if Assigned (fEndCompetitorCmd) then
          fEndCompetitorCmd;
      end
    else if sf [0]= '_STEA' then
      begin
      end
    else if sf [0]= '_ETEA' then
      begin
        if Assigned (fEndTeamCmd) then
          fEndTeamCmd;
      end
    else if sf [0]= '_PNTY' then
      begin
      end
    else if sf [0]= '_LSHT' then
      begin
      end
    else if sf [0]= '_LSRS' then
      begin
      end
    else if sf [0]= '_SOSH' then
      begin
      end
    else if sf [0]= '_SOSR' then
      begin
      end
    else if sf [0]= '_SPNS' then
      begin
      end
    else if sf [0]= '_SCPH' then
      begin
      end
    else if sf [0]= '_SSTA' then
      begin
      end
    else if sf [0]= '_ESTA' then
      begin
        if Assigned (fEndStageCmd) then
          fEndStageCmd;
      end
    else if sf [0]= '_CSER' then
      begin
      end
    else if sf [0]= '_SUBT' then
      begin
        if sf.Count< 11 then
          begin
            sf.Free;
            exit;
          end;
        val (sf [2],lane,n);
        val (sf [3],startno,n);
        val (sf [9],priscore,n);
        val (sf [10],secscore,n);
        if Assigned (fSubTotalCmd) then
          fSubTotalCmd (lane,startno,priscore,secscore);
      end
    else
      begin
        // ����������� �������
        if Assigned (fUnknownCmd) then
          fUnknownCmd (s);
      end;
  finally
    sf.Free;
  end;
end;

procedure TSiusDataMonitor.ResetBuffer;
begin
  fBuffer:= '';
end;

procedure TSiusDataMonitor.set_Active(const Value: boolean);
begin
  fClient.Active:= Value;
end;

procedure TSiusDataMonitor.set_Host(const Value: string);
begin
  fClient.Host:= Value;
end;

{procedure TSiusDataMonitor.set_IP(const Value: longint);
begin
  fTCP.IP:= Value;
end;}

procedure TSiusDataMonitor.Simulate(s: TStrings);
var
  i: integer;
begin
  for i:= 0 to s.Count-1 do
    begin
      try
        if Assigned (fOnCmd) then
          fOnCmd (s [i]);
        ParseCommand (s [i]);
      except
      end;
    end;
end;

{ TLaneShooter }

procedure TLaneShooter.Clear;
var
  i: integer;
begin
  for i:= 0 to Length (fPhases)-1 do
    fPhases [i].Free;
  SetLength (fPhases,0);
end;

constructor TLaneShooter.Create;
begin
  inherited;
  fLane:= 0;
  fStartno:= 0;
  fName:= '';
  fNation:= '';
  fObject:= nil;
  fCommands:= TStringList.Create;
  fChanged:= false;
  SetLength (fPhases,0);
  fCurrentPhase:= nil;
end;

destructor TLaneShooter.Destroy;
begin
  fCommands.Free;
  Clear;
  fCurrentPhase:= nil;
  inherited;
end;

function TLaneShooter.get_Phase(index: integer): TSiusPhase;
begin
  if (index< 0) or (index>= Length (fPhases)) then
    Result:= nil
  else
    Result:= fPhases [index];
end;

function TLaneShooter.InnerTens: integer;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fPhases)-1 do
    Result:= Result+fPhases [i].InnerTens;
end;

function TLaneShooter.PhasesCount: integer;
begin
  Result:= Length (fPhases);
end;

function TLaneShooter.PriSum: DWORD;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fPhases)-1 do
    Result:= Result+fPhases [i].PriSum;
end;

function TLaneShooter.SecSum: DWORD;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fPhases)-1 do
    Result:= Result+fPhases [i].SecSum;
end;

procedure TLaneShooter.SetPhase(index: integer);
var
  i,l: integer;
begin
  l:= Length (fPhases);
  if index>= l then
    begin
      SetLength (fPhases,index+1);
      for i:= l to index do
        fPhases [i]:= TSiusPhase.Create;
    end;
  fCurrentPhase:= fPhases [index];
end;

function TLaneShooter.ShotsCount: integer;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fPhases)-1 do
    Result:= Result+fPhases [i].ShotsCount;
end;

{ TShooters }

function TShooters.Add(startno: integer): integer;
var
  idx: integer;
  obj: TObject;
begin
  idx:= Length (fShooters);
  SetLength (fShooters,idx+1);
  fShooters [idx]:= TLaneShooter.Create;
  fShooters [idx].fStartno:= startno;
  if Assigned (fRequestData) then
    begin
      fRequestData (self,startno,obj);
      fShooters [idx].DataObject:= obj;
    end;
  Result:= idx;
end;

function TShooters.AddShot(lane, startno, priscore, secscore: integer; sighter: boolean; innerten: boolean): integer;
var
  sh: TLaneShooter;
  idx: integer;
begin
  idx:= FindStartNo (startno);
  Result:= idx;
  if idx< 0 then
    exit;
  sh:= fShooters [idx];
  sh.fStartno:= startno;
  if sighter then
    begin
      sh.fSighters:= sh.fSighters+1;
      if (secscore= 0) and (priscore<> 0) then
        sh.fLastSighter:= priscore
      else
        sh.fLastSighter:= secscore;
      sh.fChanged:= true;
    end
  else
    begin
      if sh.CurrentPhase<> nil then
        if sh.CurrentPhase.CurrentGroup<> nil then
          begin
            sh.CurrentPhase.CurrentGroup.AddShot (priscore,secscore,sighter,innerten);
            sh.fChanged:= true;
          end;
    end;
end;

function TShooters.AssignIssfId(startno: integer; issfid: string): integer;
var
  sh: TLaneShooter;
  idx: integer;
begin
  idx:= FindStartNo (startno);
  Result:= idx;
  if idx< 0 then
    exit;
  sh:= fShooters [idx];
  sh.fIssfid:= issfid;
end;

function TShooters.AssignLane(lane, startno: integer): integer;
var
  sh: TLaneShooter;
  idx: integer;
begin
  // ����������� � ���������� ������ ����� ���������
  idx:= FindStartNo (startno);
  Result:= idx;
  if idx< 0 then
    exit;
  sh:= fShooters [idx];
  sh.fLane:= lane;
end;

function TShooters.AssignName(lane, startno: integer; name: string): integer;
var
  sh: TLaneShooter;
  idx: integer;
begin
  // ����������� �������
  idx:= FindStartNo (startno);
  Result:= idx;
  if idx< 0 then
    exit;
  sh:= fShooters [idx];
  sh.fLane:= lane;
  sh.fName:= name;
end;

function TShooters.AssignNation(lane, startno: integer; nation: string): integer;
var
  sh: TLaneShooter;
  idx: integer;
begin
  // ����������� ������ (������)
  idx:= FindStartNo (startno);
  Result:= idx;
  if idx< 0 then
    exit;
  sh:= fShooters [idx];
  sh.fLane:= lane;
  sh.fNation:= nation;
end;

procedure TShooters.Clear;
var
  i: integer;
begin
  for i:= 0 to Length (fShooters)-1 do
    fShooters [i].Free;
  SetLength (fShooters,0);
end;

function TShooters.Count: integer;
begin
  Result:= Length (fShooters);
end;

constructor TShooters.Create;
begin
  SetLength (fShooters,0);
  fAutoAdd:= true;
end;

destructor TShooters.Destroy;
var
  i: integer;
begin
  for i:= 0 to Length (fShooters)-1 do
    fShooters [i].Free;
  SetLength (fShooters,0);
  fShooters:= nil;
  inherited;
end;

{
function TShooters.FindLane(lane: integer;
  createnew: boolean): TLaneShooter;
var
  i: integer;
begin
  Result:= nil;
  for i:= 0 to Length (fShooters)-1 do
    if fShooters [i].fLane= lane then
      begin
        Result:= fShooters [i];
        break;
      end;
  if (Result= nil) and (createnew) then
    begin
      i:= Length (fShooters);
      SetLength (fShooters,i+1);
      fShooters [i]:= TLaneShooter.Create;
      fShooters [i].fLane:= lane;
      Result:= fShooters [i];
    end;
end;
}

function TShooters.FindStartNo(startno: integer): integer;
var
  i: integer;
//  obj: TObject;
begin
  // ���� ������� � �������� ��������� �������
  Result:= -1;
  for i:= 0 to Length (fShooters)-1 do
    if fShooters [i].fStartno= startno then
      begin
        Result:= i;
        break;
      end;
  // ���� ����� �� ������, �� ���� ���������� nil
  // ���� ������� ������ � ������ �������
  if (Result= -1) and (fAutoAdd) then
    Result:= Add (startno);
end;

function TShooters.get_Shooter(index: integer): TLaneShooter;
begin
  Result:= fShooters [index];
end;

{ TSiusGroup }

procedure TSiusGroup.AddShot(priscore, secscore: integer;
  sighter: boolean; innerten: boolean);
var
  idx: integer;
begin
  idx:= Length (fShots);
  SetLength (fShots,idx+1);
  fShots [idx]:= ShotRec (priscore,secscore,sighter,innerten);
end;

procedure TSiusGroup.Clear;
begin
  SetLength (fShots,0);
end;

constructor TSiusGroup.Create;
begin
  inherited;
  SetLength (fShots,0);
end;

destructor TSiusGroup.Destroy;
begin
  Clear;
  inherited;
end;

function TSiusGroup.get_Shot(index: integer): TSiusShotRec;
begin
  Result:= fShots [index];
end;

function TSiusGroup.InnerTens: integer;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fShots)-1 do
    begin
      if fShots [i]._innerten then
        inc (Result);
    end;
end;

function TSiusGroup.PriSum: DWORD;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fShots)-1 do
    Result:= Result+fShots [i]._priscore;
end;

function TSiusGroup.SecSum: DWORD;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fShots)-1 do
    Result:= Result+fShots [i]._secscore;
end;

procedure TSiusGroup.set_Shot(index: integer; const Value: TSiusShotRec);
var
  i,l: integer;
begin
  l:= Length (fShots);
  if index>= l then
    begin
      SetLength (fShots,index+1);
      for i:= l to index-1 do
        fShots [i]:= ShotRec (0,0,false,false);
    end;
  fShots [index]:= Value;
end;

function TSiusGroup.ShotsCount: integer;
begin
  Result:= Length (fShots);
end;

{ TSiusPhase }

procedure TSiusPhase.Clear;
var
  i: integer;
begin
  for i:= 0 to Length (fGroups)-1 do
    fGroups [i].Free;
  SetLength (fGroups,0);
  fCurrentGroup:= nil;
end;

constructor TSiusPhase.Create;
begin
  inherited;
  SetLength (fGroups,0);
  fCurrentGroup:= nil;
end;

destructor TSiusPhase.Destroy;
begin
  Clear;
  inherited;
end;

function TSiusPhase.get_Group(index: integer): TSiusGroup;
begin
  if (index< 0) or (index>= Length (fGroups)) then
    Result:= nil
  else
    Result:= fGroups [index];
end;

function TSiusPhase.GroupsCount: integer;
begin
  Result:= Length (fGroups);
end;

function TSiusPhase.InnerTens: integer;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fGroups)-1 do
    Result:= Result+fGroups [i].InnerTens;
end;

function TSiusPhase.PriSum: DWORD;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fGroups)-1 do
    Result:= Result+fGroups [i].PriSum;
end;

function TSiusPhase.SecSum: DWORD;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fGroups)-1 do
    Result:= Result+fGroups [i].SecSum;
end;

procedure TSiusPhase.SetGroup(index: integer);
var
  l,i: integer;
begin
  l:= Length (fGroups);
  if index>= l then
    begin
      SetLength (fGroups,index+1);
      for i:= l to index do
        fGroups [i]:= TSiusGroup.Create;
    end;
  fCurrentGroup:= fGroups [index];
end;

function TSiusPhase.ShotsCount: integer;
var
  i: integer;
begin
  Result:= 0;
  for i:= 0 to Length (fGroups)-1 do
    Result:= Result+fGroups [i].ShotsCount;
end;

{ TSiusDataCollector }

constructor TSiusDataCollector.Create;
begin
  inherited;
  fShooters:= TShooters.Create;
  fCommands:= TStringList.Create;
  fSiusData:= TSiusDataMonitor.Create;
  fSiusData.OnConnect:= Connect;
  fSiusData.OnDisconnect:= Disconnect;
  fSiusData.OnName:= OnName;
  fSiusData.OnIssfID:= OnIssfId;
  fSiusData.OnStartNo:= OnStartNo;
  fSiusData.OnNation:= OnNation;
  fSiusData.OnShot:= OnShot;
  fSiusData.OnStartCompetitionList:= OnStartCompList;
  fSiusData.OnEndCompetitionList:= OnEndCompList;
  fSiusData.OnEndCompetitor:= OnEndCompetitor;
  fSiusData.OnEndTeam:= OnEndTeam;
  fSiusData.OnEndStage:= OnEndStage;
  fSiusData.OnCmd:= OnCmd;
  fSiusData.OnGroupHeader:= OnGroupHeader;
  fSiusData.OnPracticeHeader:= OnPracticeHeader;
end;

destructor TSiusDataCollector.Destroy;
begin
  fSiusData.Free;
  fCommands.Free;
  fShooters.Free;
  inherited;
end;

procedure TSiusDataCollector.Disconnect(Sender: TObject);
begin
  if Assigned (fOnDisconnect) then
    fOnDisconnect (self);
end;

procedure TSiusDataCollector.Connect(Sender: TObject);
begin
  fCommands.Clear;
  fShooters.Clear;
  if Assigned (fOnConnect) then
    fOnConnect (self);
  if Assigned (fOnUpdate) then
    fOnUpdate (self,-1,-1,-1,-1);
end;

procedure TSiusDataCollector.OnCmd(cmd: string);
begin
  fCommands.Add (cmd);
end;

procedure TSiusDataCollector.OnEndCompetitor;
begin
end;

procedure TSiusDataCollector.OnEndCompList;
begin
end;

procedure TSiusDataCollector.OnEndStage;
begin
end;

procedure TSiusDataCollector.OnEndTeam;
begin
end;

procedure TSiusDataCollector.OnGroupHeader(lane, startno, group,
  kind: integer);
var
  sh: TLaneShooter;
  idx: integer;
begin
  if (kind<> 0) and (group<> 0) then
    begin
      idx:= fShooters.FindStartNo (startno);
      if idx< 0 then
        exit;
      sh:= fShooters.Shooters [idx];
      if sh.CurrentPhase<> nil then
        begin
          sh.CurrentPhase.SetGroup (group-1);
          sh.CurrentPhase.CurrentGroup.Clear;
        end;
    end;
end;

procedure TSiusDataCollector.OnIssfId(startno: integer; issfid: string);
var
  idx: integer;
begin
  idx:= fShooters.AssignIssfId (startno,issfid);
  if idx< 0 then
    exit;
  if Assigned (fOnUpdate) then
    fOnUpdate (self,idx,-1,-1,-1);
end;

procedure TSiusDataCollector.OnName(lane, startno: integer; name: string);
var
  idx: integer;
begin
  idx:= fShooters.AssignName (lane,startno,name);
  if idx< 0 then
    exit;
  if Assigned (fOnUpdate) then
    fOnUpdate (self,idx,-1,-1,-1);
end;

procedure TSiusDataCollector.OnNation(lane, startno: integer; nation: string);
var
  idx: integer;
begin
  idx:= fShooters.AssignNation (lane,startno,nation);
  if idx< 0 then
    exit;
  if Assigned (fOnUpdate) then
    fOnUpdate (self,idx,-1,-1,-1);
end;

procedure TSiusDataCollector.OnPracticeHeader(lane, startno, seq, code,
  phase: integer);
var
  sh: TLaneShooter;
  idx: integer;
begin
  idx:= fShooters.FindStartNo (startno);
  if idx< 0 then
    exit;
  sh:= fShooters.Shooters [idx];
  sh.SetPhase (phase);
end;

procedure TSiusDataCollector.OnShot(lane, startno, kind, attr, priscore,
  secscore, targetindex, practicenum: integer; x, y: double);
var
  idx: integer;
begin
  if (attr and SHOT_ILLEGAL<> 0) then
    exit;
  if (kind<> 3) then
    exit;
  idx:= fShooters.AddShot (lane,startno,priscore,secscore,attr and SHOT_SIGHTING<> 0,attr and SHOT_INNERTEN<> 0);
  if idx< 0 then
    exit;
  if Assigned (fOnUpdate) then
    fOnUpdate (self,idx,-1,-1,-1);
end;

procedure TSiusDataCollector.OnStartCompList(time, name: string);
begin
end;

procedure TSiusDataCollector.OnStartNo(lane, startno: integer);
var
  idx: integer;
begin
  idx:= fShooters.AssignLane (lane,startno);
  if idx< 0 then
    exit;
  if Assigned (fOnUpdate) then
    fOnUpdate (self,idx,-1,-1,-1);
end;

procedure TSiusDataCollector.Reset;
begin
  fShooters.Clear;
  fCommands.Clear;
  fSiusData.ResetBuffer;
  if Assigned (fOnUpdate) then
    fOnUpdate (self,-1,-1,-1,-1);
end;

end.

